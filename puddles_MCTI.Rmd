---
title: "Projeto Peppa Pig"
output:
  html_document: 
    df_print: paged
---

```{css, echo=FALSE}
body {
  font-family: "Source Sans Pro";
}

.dygraph-legend, .dygraph-axis-label {
  font-family: "Source Sans Pro";
}

.dygraph-label {
  font-family: "Source Sans Pro";
}

```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl)
library(extrafont)
library(kableExtra)
library(lubridate)
library(gganimate)
library(scales)
loadfonts()

tema <- function(){
    theme_minimal() +
    theme(
      text = element_text(family = "Source Sans Pro", colour = "grey20"),
      axis.text = element_text(family = "Source Sans Pro", colour = "grey20"),
      title = element_text(face = "bold"),
      plot.subtitle = element_text(face = "plain"),
      plot.caption = element_text(face = "italic"),
      panel.grid.major = element_blank(), 
      panel.grid.minor = element_blank(),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 8),
      axis.ticks.x = element_line(),
      axis.title = element_text(size = 7),
      legend.position = 'bottom')
}
```

## Dados Siafi

Uma visão geral da estrutura dos dados do Siafi que serão utilizados.

```{r}

dados_Siafi <- read.csv2('data/dadosMCTI.csv')
colnames(dados_Siafi) <- c("Ano", "Mes", "Dia", "Data", 
                           "idItem", "nomeItem", "codItem", 
                           "idOrgao", "codOrgao", "nomeOrgao", 
                           "Movimento")

head(dados_Siafi, 5) %>% 
  kable("html", format.args = list(big.mark=".", decimal.mark=",")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

## Análise geral dos órgão do MCTI

Vamos tratar os dados para obter uma matriz com os saldos diários para todo o período considerado, por órgão do MCTI.

```{r}

# vamos tratar os dados. comentarios nas notas de cada linha

dados <- dados_Siafi %>%
  mutate(Date = if_else(Mes == 0, ymd(paste0(Ano,"-01-01")), dmy(Data))) %>% # (0)
  group_by(Date, codOrgao) %>%
  summarise(Movimento = sum(as.numeric(as.character(Movimento)))) %>% # (1)
  ungroup() %>% # (2)
  select(Date, codOrgao, Movimento) %>% # (3)
  spread(key = codOrgao, value = Movimento, fill = 0) %>% # (4)
  arrange(Date) %>% # (5)
  complete(Date = seq(min(Date), max(Date), by = "days")) %>% # (6)
  replace(is.na(.), 0) %>% # (7)
  mutate_at(-1, funs(cumsum(.))) %>% # (8)
  gather(-1, key = "codOrgao", value = "Saldo") # (9)

# (0) criar primeiro a coluna no formato de data, tratando os meses de abertura. importante: tem que usar o dplyr::if_else senão o ifelse muda o tipo do dado! :/

# poderia ter usado também:

# mutate(Date = if_else(Mes == 0, as.Date(paste0(Ano,"-01-01")), 
#                       as.Date(paste(Ano, Mes, Dia, sep = "-"))))

# (1) esse group_by com summarise é para somar eventuais registros repetidos. Ou seja, preciso ficar com um movimento para cada dia, para cada orgao. como atribuí que o saldo de abertura seria um movimento no dia 01/01, e tinha um caso em que havia de fato movimento no dia 01/01 em um orgao, apareciam dois registros no dia 01/01 nesse orgao. o summarise elimina esse problema.

# (2) por um motivo que ainda não entendo, sem esse ungroup ele não calcula o cumsum corretamente.

# (3) estou pegando apenas o essencial para que minha planilha fique com apenas uma linha por data, quando eu fizer o spread. depois trago os nomes dos órgãos de novo via join, se for necessário.

# (4) com o spread, um orgao que eventualmente não possuía movimento em determinado dia vai aparecer com "NA". Preenchi com 0 pq depois vou usar o cumsum para calcular os saldos.

# (5) classificando por data para o cumsum ter o significado que quero: saldos acumulados diários.

# (6) o complete vai completar as datas faltantes considerando a sequencia de dias entre o menor e o maior dia presente nos dados. Os valores para esses dias faltantes serão completados com "NA", então...
  
# (7) o replace substitui esses NAs por 0.

# (8) agora uso o cumsum para calcular os totais acumulados em cada coluna (que neste ponto se referem a cada órgão.) usei o -1 na referência do mutate_at para calcular essa soma acumulada para TODAS as colunas, EXCETO a primeira (pq ela é a data).

# (9) agora, de maneira semelhante, uso o -1 para dizer que quero empilhar todas as colunas, exceto a primeira, que é a coluna de data.

```
Em seguida, vamos calcular alguns sumários estatísticos (mínimos, máximos, médias e medianas) por órgão, para todo o período, e vamos terminar de preparar os dados para visualizá-los.

```{r}
# criar uma tabelinha com os códigos e nomes dos órgãos para posteriormente levar essas informações à tabela processada

nomes_orgaos <- data.frame(
  "codOrgao" = factor(unique(dados_Siafi$codOrgao)),
  "nomeOrgao" = factor(unique(dados_Siafi$nomeOrgao)),
  "siglaOrgao" = c("FNDCT", "NUCLEBRAS", "INB", "CNDCT", "AEB", 
                   "CNEN", "MCTI", "ANATEL", "CNTEA", "FUST", "FUNTTEL"))

# elaborar sumários para gráficos (e para ordenar os órgãos por média descrescente)

sumario_dados <- dados %>%
  group_by(codOrgao) %>%
  summarise(minimo   = min(Saldo, na.rm = TRUE),
            data_min = Date[which.min(Saldo)],
            maximo   = max(Saldo, na.rm = TRUE),
            data_max = Date[which.max(Saldo)],
            mediana  = median(Saldo, na.rm = TRUE),
            media    = mean(Saldo)) %>%
  ungroup() %>%
  arrange(desc(media)) %>%
  left_join(nomes_orgaos) %>% 
  mutate(codOrgao   = fct_reorder(codOrgao, media, desc = TRUE), # (1)
         nomeOrgao  = fct_reorder(nomeOrgao, media, desc = TRUE),
         siglaOrgao = fct_reorder(siglaOrgao, media, desc = TRUE),
         Orgao      = paste(codOrgao, nomeOrgao, sep = " - "))
  
dados <- dados %>%
  left_join(sumario_dados)

# (1) tem um jeito melhor de ordenar vários factors pelo mesmo critério? talvez com purr::map()...

```

### Visualizações

O gráfico abaixo demonstra as médias dos saldos diários da conta de limite de saque (que representa a parcela da Conta Única da União atribuida ao órgão) dos órgãos do MCTI no período considerado.

```{r}
ggplot(sumario_dados, aes(y = media, x = siglaOrgao)) +
  geom_bar(stat = "identity", fill = "goldenrod", color = "white") +
  geom_text(aes(y = media + 2000, label = paste(format(round(media/1000000,0), 
                                big.mark = ".", decimal.mark = ","), "mi")),
            color = "grey50", size = 2.5, 
            hjust = 0,
            position = "identity",
            family = "Source Sans Pro") +
  coord_flip() +
  scale_y_continuous(labels = function(x) {format(x/1000000, big.mark = ".", decimal.mark=",", scientific = FALSE)}) +
  labs(y = "Valores em milhões de R$",
       x = NULL,
       title = "Média dos saldos financeiros diários - Ministério da Ciência e Tecnologia",
       subtitle = "Período de janeiro de 2017 a agosto de 2018") +
  expand_limits(y = max(sumario_dados$media * 1.1)) +
  tema() + theme(legend.position = "none")
```

O gráfico acima demonstra a média, mas para ter uma melhor ideia da distribuição desses valores no período, elaboramos o gráfico abaixo com todos os saldos diários de cada órgão do MCTI plotados. O valor do saldo financeiro para cada dia é representado por uma linha clara. Concentrações de saldos numa mesma faixa de valores produzem regiões mais escuras. O gráfico utiliza uma escala logarítmica, para permitir uma melhor visualização de todos os órgãos, em razão da discrepância dos saldos observados em cada órgão.

```{r}
graf_estatico <- ggplot(dados, aes(y = Saldo, x = siglaOrgao)) +
  geom_tile(aes(y = round(Saldo,0)), fill = "darkgoldenrod", alpha = 0.1, width = 1, height = 0.01) +
  coord_flip() +
  geom_hline(yintercept = min(dados$Saldo), linetype = "dotted") +
  geom_hline(yintercept = median(dados$Saldo), linetype = "dotted") +
  annotate(geom = "text", x = length(unique(dados$Orgao)) + 1, y = min(dados$Saldo), 
           label = paste("Mínimo geral: ", 
                         format(round(min(dados$Saldo),0), 
                                big.mark = ".", decimal.mark = ",")),
           color = "grey50", size = 2, hjust = 0,
           family = "Source Sans Pro") +
  annotate(geom = "text", x = length(unique(dados$Orgao)) + 1, y = median(dados$Saldo), 
           label = paste("Mediana geral: ", 
                         format(round(median(dados$Saldo),0), 
                                big.mark = ".", decimal.mark = ",")),
           color = "grey50", size = 2, hjust = 0,
           family = "Source Sans Pro") +
  scale_y_log10(labels = function(x) {format(x, big.mark = ".", decimal.mark=",", scientific = FALSE)}) +
  labs(y = "Valores em R$ (escala logarítmica)",
       x = NULL,
       title = "Saldos financeiros diários - Ministério da Ciência e Tecnologia",
       subtitle = "Período de janeiro de 2017 a agosto de 2018") +
  expand_limits(y = max(dados$Saldo) * 2) + 
  tema() + theme(legend.position = "none")

graf_estatico
```

O mesmo gráfico, porém com a inclusão de diagramas de caixas, indicando medianas, quartis, mínimos, máximos e outliers.

```{r}
graf_estatico + geom_boxplot()
```

Por fim, uma animação que mostra a evolução dos valores diários no tempo, com a indicação dos valores mínimos (em <span style="color: firebrick;">vermelho</span>) e máximos <span style="color: navy;">azul</span>.

```{r, fig.width=7, fig.height=7}
graf_estatico +
  geom_tile(aes(y = ifelse(Date>data_min,minimo,NA)), fill = "firebrick", alpha = 0.4, width = 1, height = 0.03) +
  geom_tile(aes(y = ifelse(Date>data_max,maximo,NA)), fill = "navy", alpha = 0.4, width = 1, height = 0.03) +  
  geom_text(aes(y = ifelse(Date>data_min,minimo * 0.95,NA), 
                label = paste(format(round(minimo/1000000,1), big.mark = ".", decimal.mark=",", scientific = FALSE), "mi")), 
            hjust = 1,
            size = 2.5, 
            family = "Source Sans Pro",
            fontface = "plain",
            color = "firebrick"
            ) +
  geom_text(aes(y = ifelse(Date>data_max,maximo * 1.05,NA), 
                label = paste(format(round(maximo/1000000,1), big.mark = ".", decimal.mark=",", scientific = FALSE), "mi")), 
            hjust = 0,
            size = 2.5, 
            family = "Source Sans Pro",
            fontface = "plain",
            color = "navy"
            ) +
  labs(subtitle = "Posição em {frame_time}") +
  tema() + theme(legend.position = "none") +
  transition_time(Date) +
  ease_aes('linear')
```

## Visualização de todas as movimentações financeiras de um órgão

Nesta seção, vamos tentar construir uma visualização que demonstre todos os pagamentos e recebimentos, além dos saldos financeiros, dia a dia, de um determinado órgão do MCTI.

Vamos carregar os dados e fazer um sumário das movimentações provocadas por cada tipo de documento.

```{r}

dados_fluxo_Siafi <- read_excel('data/MCTI_limSqDiarioDoc.xlsx')

colnames(dados_fluxo_Siafi) <- c(
  "codOrgao", 
  "nomeOrgao", 
  "Data", 
  "Documento", 
  "docObservacao", 
  "Item", 
  "Movimento")

# vamos usar um pipe parecido com o da análise geral, mas antes precisamos de outras informacoes.

# aqui um resumo dos movimentos para podermos mapear os tipos de movimento possíveis.

dados_fluxo_Siafi %>%
  mutate(Movimento = as.numeric(as.character(Movimento)),
         tipoDoc = ifelse(str_sub(Documento, 1, 13) == "SALDO INICIAL",
                          "Saldo de abertura",
                          str_sub(Documento, 16, 17)),
         tipoMov = ifelse(Movimento < 0, "Negativo", "Positivo")) %>%
  group_by(tipoDoc, tipoMov) %>%
  summarise(Total = format(sum(Movimento),big.mark=".", decimal.mark=","),
            Quantidade = n()) %>%
  kable("html", format.args = list(big.mark=".", decimal.mark=",")) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"))


```

Assim, indetificamos sete possíveis movimentos:

* Receitas próprias - movimentos positivos por RAs;
* Recebimentos de recursos do Tesouro - movimentos positivos por PFs;
* Anulações de pagamentos - movimentos positivos por DF, DR, GF, GP, GR ou OB;
* Ajustes contábeis - movimentos por NS;
* Pagamentos - movimentos negativos por DF, DR, GF, GP, GR ou OB;
* Ajustes na receita arrecadada (anulações, retificações etc.): movimentos negativos por RA; e
* Liberações de recursos para outros órgãos - movimentos negativos por PFs.

Vamos tratar a nossa base para incorporar essas informações.

```{r}
# criando tabela de classificadores de movimentos financeiros

docsPgtos <- c("DF","DR","GF","GP","GR","OB")

tab_class_movimentos <- data.frame(
  "classMovimento" = c("Recebimentos", 
                       "Receitas", 
                       "AnulacoesDespesas",
                       "AjustesContabeis",
                       "AjustesContabeis",
                       "Despesas",
                       "AjustesReceitas",
                       "Liberacoes",
                       "SaldoAbertura",
                       "SaldoAbertura"),
  "tipoDoc"        = c("PF",
                       "RA",
                       "Docs pagamentos",
                       "NS",
                       "NS",
                       "Docs pagamentos",
                       "RA",
                       "PF",
                       "Saldo de abertura",
                       "Saldo de abertura"),
  "tipoMov"        = c("Positivo",
                       "Positivo",
                       "Positivo",
                       "Positivo",
                       "Negativo",
                       "Negativo",
                       "Negativo",
                       "Negativo",
                       "Positivo",
                       "Negativo"))

# tratando os dados

dados_fluxo <- dados_fluxo_Siafi %>%
  mutate(Movimento = as.numeric(as.character(Movimento)),
         tipoDoc_ = ifelse(str_sub(Documento, 1, 13) == "SALDO INICIAL",
                           "Saldo de abertura",
                           str_sub(Documento, 16, 17)),
         tipoDoc  = if_else(tipoDoc_ %in% docsPgtos, 
                            "Docs pagamentos", 
                            tipoDoc_),
         tipoMov  = ifelse(Movimento < 0, "Negativo", "Positivo"),
         Date     = if_else(str_sub(Data, 1, 4) == "000/", 
                            as.Date(paste0(str_sub(Data, 5, 8),"-01-01")),
                            dmy(Data))) %>%
  left_join(tab_class_movimentos) %>%
  group_by(Date, classMovimento) %>% 
  summarise(Movimento = sum(Movimento)) %>%
  ungroup() %>%
  select(Date, classMovimento, Movimento) %>%
  spread(key = classMovimento, value = Movimento, fill = 0) %>%
  complete(Date = seq(min(Date), max(Date), by = "days")) %>% # (1)
  replace(is.na(.), 0) %>%
  mutate(Movimento      = rowSums(.[-1]), # (2)
         Saldo          = cumsum(Movimento),
         Saldo_anterior = ifelse(row_number() == 1, Saldo, lag(Saldo)))
  
# (1) como usar o "fill = list()" aqui? para não ter que usar esse replace depois?

# (2) rowSums(.[-1]) faz a soma de todas as colunas, exceto a primeira.

```

Gráfico. Continuar daqui. Subdividir "Ajustes contábeis".

```{r, fig.height=25, fig.width=11}

ggplot(dados_fluxo %>% filter(Date <= "2017-07-31"), aes(y = Date, yend = Date)) +
  geom_point(aes(x = Saldo)) +
  geom_segment(aes(x    = Saldo_anterior,
                   xend = Saldo_anterior + Recebimentos),
               color = "navy", position = position_nudge(y = 0.1)) +
  geom_segment(aes(x    = Saldo_anterior + Recebimentos,
                   xend = Saldo_anterior + Recebimentos + Receitas),
               color = "blue", position = position_nudge(y = 0.1)) +
  geom_segment(aes(x    = Saldo_anterior + Recebimentos + Receitas,
                   xend = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas),
               color = "purple", position = position_nudge(y = 0.1)) + 
  geom_segment(aes(x    = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas,
                   xend = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas + AjustesContabeis),
               color = "green", position = position_nudge(y = -0.1)) + # (1)
  geom_segment(aes(x    = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas + AjustesContabeis,
                   xend = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas + AjustesContabeis + Despesas),
               color = "red", position = position_nudge(y = -0.1)) + 
  geom_segment(aes(x    = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas + AjustesContabeis + Despesas,
                   xend = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas + AjustesContabeis + Despesas + Liberacoes),
               color = "firebrick", position = position_nudge(y = -0.1)) +
  geom_segment(aes(x    = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas + AjustesContabeis + Despesas + Liberacoes,
                   xend = Saldo_anterior + Recebimentos + Receitas + AnulacoesDespesas + AjustesContabeis + Despesas + Liberacoes + AjustesReceitas),
               color = "pink", position = position_nudge(y = -0.1)) +
  scale_x_continuous(labels = function(x) {format(x/1000000, big.mark = ".", decimal.mark=",", scientific = FALSE)}) +
  scale_y_discrete(labels = rev(levels(as.factor(dados_fluxo$Date)))) +
  labs(x = "Valores em milhões de R$",
       y = NULL,
       title = "Movimentação diária - MCTI",
       subtitle = "Período de janeiro de 2017 a julho de 2017") +
  tema() + theme(legend.position = "none")

# (1) acho q vou ter q subdividir ajustes contabeis em "positivo" e "negativos"
```

```{r}
dados_fluxo_gather <- dados_fluxo %>% filter(Date < "2017-03-30") %>%
  gather(-1, key = "tipoMov", value = "Valor")
```

```{r}

```


## Comentários

### Questões a considerar

* uma forma de agrupar as UGs pelo perfil "financeiro"? Algo como o gráfico barcode, mas com as UGs agrupadas por perfil, e não por órgão.

* [ok] refazer para MCTI (24000), por órgão (são bem mas UGs).

* [ok] a variável tempo tem que ser uniforme, preencher os saldos para os dias em que não houve movimentação. arrumar uma forma de gerar uma série para todos os dias do período de interesse.

* [ok] usar gganimate para fazer alguma animação

* usar geom_segment, no lugar de geom_path, no gráfico dos recebimentos e pagamentos? teria a vantagem de usar um único dataset, sem precisar fazer a ginástica que fiz.

* melhorar formatação da tabela de sumário dos movimentos por tipo documento

### Descobertas, aprendizados, recursos interessantes

* https://github.com/htmlwidgets/sparkline
* `cumsum()`, `lag()`
* https://stackoverflow.com/questions/41668795/using-mutate-with-dates-gives-numerical-values
* ou seja, o `ifelse` muda o tipo do dado... o `if_else` do `dplyr`, não.
* para completar um período de dias: https://blog.exploratory.io/populating-missing-dates-with-complete-and-fill-functions-in-r-and-exploratory-79f2a321e6b5
* `complete`, do tidyr
* animações: https://www.idg.tv/video/89987/r-tip-animations-in-r